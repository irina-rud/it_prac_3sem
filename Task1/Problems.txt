1) Нет, не будет. при такой последовательности действий:
	1. 1й поток : victim.store(1);
	2. 0й : victim.store(0);
	3. исполнение кода для первого потока, первый поток заходит в критическую секцию
	4. исполнение кода для нулевого потока, он тоже зашел в критическую секцию
Два потока в критической секции. Беда.

2) Предположим, что физическое расположение трех процессоров:
   P1, P2 и P3, приводит к неравномерности времени доступа к месту нахождения общей переменной блокировки.
   Порядок увеличения времени доступа к переменной блокировки для трех процессоров P1 <P2 <P3. 
   Таким образом, P1 всегда является наиболее выгодном положении при приобретении замка, а затем P2, 
   P3 находится в наиболее неблагоприятном положении. 
   Как эта ситуация приводит к зависанию при отсутствии гарантии справедливости показано ниже на псевдокоде:

   while (1) {
     lock {
          …
          critical section
          …
     }
     unlock
	}

	Starvation of P3
Time	P1                 	       P2	                    P3
1	lock attempt (success)	lock attempt (failed)	lock attempt (failed)
2	critical section	          spin	                  spin
3	release lock	        lock attempt (success)	lock attempt (failed)
4	...	                      critical section	          spin
5	lock attempt (failed)	      ...	                  ...
6	lock attempt (success)	   release lock	        lock attempt (failed)
7	critical section	          spin	                  spin



TАS также подвержен данной проблеме.